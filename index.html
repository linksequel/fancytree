<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; border-radius: 8px; transform: scaleX(-1); opacity: 0.7; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none; }
        .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); pointer-events: auto; display: flex; gap: 10px; }
        button, input::file-selector-button {
            background: rgba(212, 175, 55, 0.8); border: 1px solid #D4AF37; color: #002200;
            padding: 8px 16px; border-radius: 20px; cursor: pointer; font-weight: bold;
            transition: all 0.3s;
        }
        button:hover, input::file-selector-button:hover { background: #D4AF37; box-shadow: 0 0 10px #D4AF37; }
        #status { position: absolute; top: 20px; right: 20px; text-align: right; text-shadow: 0 0 5px #D4AF37; }
        .instruction { font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; }
        h1 { margin: 0; font-size: 1.5em; color: #D4AF37; }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <video id="video-input" playsinline></video>
    <div id="ui-layer">
        <div id="status">
            <h1>Magic Christmas Tree</h1>
            <div class="instruction">‚úã Âº†ÂºÄÊâãÊéå: Êï£ÂºÄ | ‚úä Êè°Êã≥: ËÅöÂêà</div>
            <div class="instruction">üëÜ ÊçèÂêà: ÊäìÂèñÁÖßÁâá | üëã ÁßªÂä®: ÊóãËΩ¨ËßÜËßí</div>
            <div id="gesture-state" style="color: #ff3333; font-weight: bold; margin-top: 5px;">Á≠âÂæÖÊâãÂäø...</div>
        </div>
        <div class="controls">
            <input type="file" id="upload-photo" accept="image/*" multiple style="display:none">
            <button onclick="document.getElementById('upload-photo').click()">üì∏ ‰∏ä‰º†ÁÖßÁâá</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        // Particle Meshes
        let sphereGreenMesh, sphereRedMesh, sphereGoldMesh, sphereMatteMesh;
        let boxMesh;
        let caneGreenMesh, caneGoldMesh;
        let glowMesh; 
        let starMesh;
        let photoMeshes = [];
        
        // Data Arrays
        let sphereGreenData = [], sphereRedData = [], sphereGoldData = [], sphereMatteData = [];
        let boxData = [];
        let caneGreenData = [], caneGoldData = [];
        let glowData = [];
        let photoData = []; 
        let photos = [];
        
        const PARTICLE_COUNT = 3000; // Total spheres split across types
        const BOX_COUNT = 500;
        const CANE_COUNT = 400;
        const GLOW_COUNT = 800;
        
        // State
        const STATE = {
            CLOSED: 0,
            SCATTERED: 1,
            ZOOM: 2
        };
        let currentState = STATE.CLOSED;
        let targetState = STATE.CLOSED;
        
        // Zoom State Variables
        let zoomedPhotoIndex = -1;
        let zoomCameraPos = new THREE.Vector3();
        let originalCameraPos = new THREE.Vector3();
        
        // Colors
        // Matte Green, Metallic Gold, Christmas Red
        const COLOR_GREEN_MATTE = 0x2E5936;
        const COLOR_GREEN_BRIGHT = 0x32CD32; // Lime Green
        const COLOR_GOLD_METAL = 0xD4AF37;
        const COLOR_RED_BRIGHT = 0xFF0000; // Bright Red
        // Mix of dark green, bright green, bright red, and gold
        const COLORS = [COLOR_GREEN_MATTE, COLOR_GREEN_BRIGHT, COLOR_RED_BRIGHT, COLOR_RED_BRIGHT, COLOR_GOLD_METAL];

        // --- Initialization ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 35);
            camera.lookAt(0, 12, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Ensure correct color space
            container.appendChild(renderer.domElement);

            // Post-processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // Adjusted strength
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            // Main Gold Light - Warm and Bright
            const pointLight = new THREE.PointLight(0xFFD700, 2, 100);
            pointLight.position.set(5, 15, 10);
            scene.add(pointLight);
            
            // Fill Light - Cooler to contrast
            const fillLight = new THREE.PointLight(0xccccff, 1, 80);
            fillLight.position.set(-10, 5, 20);
            scene.add(fillLight);
            
            // Internal Tree Lights (Warm Glow)
            const innerLight = new THREE.PointLight(0xffaa00, 3, 30);
            innerLight.position.set(0, 10, 0);
            scene.add(innerLight);
            
            // Add some random lights for sparkle
            for(let i=0; i<8; i++) {
                const color = Math.random() > 0.6 ? 0xD4AF37 : 0xff0000;
                const pl = new THREE.PointLight(color, 1.0, 30);
                pl.position.set((Math.random()-0.5)*20, Math.random()*25, (Math.random()-0.5)*20);
                scene.add(pl);
            }

            // Controls (Mouse fallback)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;
            controls.target.set(0, 10, 0);

            // Generate Particles
            generateParticles();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('upload-photo').addEventListener('change', handlePhotoUpload);

            // Start Animation Loop
            animate();
            
            // Start MediaPipe
            initMediaPipe();
        }

        function getTreePosition(t, radiusBase, height) {
            // Volume filling cone
            const y = t * height; // 0 to H
            const maxR = radiusBase * (1 - t * 0.95); 
            // Random radius within maxR for volume
            const r = Math.sqrt(Math.random()) * maxR; 
            const theta = t * 40 + (Math.random() * Math.PI * 2); 
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            return new THREE.Vector3(x, y + 1, z); 
        }

        function getScatteredPosition() {
            const r = 12 + Math.random() * 15;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta) + 12; // Center around 12y
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        function generateParticles() {
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();

            // --- 1. Spheres (Ornaments) ---
            // Helper to create sphere mesh
            function createSphereMesh(colorHex, emissiveColor, emissiveIntensity, roughness) {
                const geo = new THREE.SphereGeometry(0.45, 16, 16);
                const mat = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    emissive: emissiveColor,
                    emissiveIntensity: emissiveIntensity,
                    metalness: 0.8,
                    roughness: roughness
                });
                return new THREE.InstancedMesh(geo, mat, PARTICLE_COUNT / 4); // Approx count
            }

            // A. Bright Green (Glowing)
            sphereGreenMesh = createSphereMesh(COLOR_GREEN_BRIGHT, COLOR_GREEN_BRIGHT, 0.6, 0.15);
            // B. Red (Glowing)
            sphereRedMesh = createSphereMesh(COLOR_RED_BRIGHT, COLOR_RED_BRIGHT, 0.6, 0.15);
            // C. Gold (Glowing)
            sphereGoldMesh = createSphereMesh(COLOR_GOLD_METAL, COLOR_GOLD_METAL, 0.4, 0.1);
            // D. Matte Green (Background - Low Glow)
            sphereMatteMesh = createSphereMesh(COLOR_GREEN_MATTE, 0x000000, 0.0, 0.6);

            // Distribute Particles
            const countPerType = PARTICLE_COUNT / 4;
            
            function fillSphereData(mesh, dataArray, count) {
                for (let i = 0; i < count; i++) {
                    const t = Math.pow(Math.random(), 0.8); // Randomize t slightly differently
                    const treePos = getTreePosition(t, 9, 24);
                    const scatteredPos = getScatteredPosition();
                    dataArray.push({ treePos, scatteredPos, currentPos: treePos.clone() });

                    dummy.position.copy(treePos);
                    dummy.scale.setScalar(0.7 + Math.random() * 0.8);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    // No need to set instanceColor since material is colored per mesh
                }
                scene.add(mesh);
            }

            fillSphereData(sphereGreenMesh, sphereGreenData, countPerType);
            fillSphereData(sphereRedMesh, sphereRedData, countPerType);
            fillSphereData(sphereGoldMesh, sphereGoldData, countPerType);
            fillSphereData(sphereMatteMesh, sphereMatteData, countPerType);


            // --- 2. Boxes (Gifts - Metallic Gold) ---
            const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const boxMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD_METAL,
                emissive: COLOR_GOLD_METAL,
                emissiveIntensity: 0.2, // Slight glow
                metalness: 1.0,
                roughness: 0.1
            });
            boxMesh = new THREE.InstancedMesh(boxGeo, boxMat, BOX_COUNT);

            for (let i = 0; i < BOX_COUNT; i++) {
                const t = Math.random();
                const y = t * 24;
                const r = 10 * (1 - t * 0.95);
                const theta = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(r * Math.cos(theta), y + 1, r * Math.sin(theta));
                const scatteredPos = getScatteredPosition();

                boxData.push({ treePos, scatteredPos, currentPos: treePos.clone() });

                dummy.position.copy(treePos);
                dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                dummy.scale.setScalar(0.8 + Math.random() * 0.8);
                dummy.updateMatrix();
                boxMesh.setMatrixAt(i, dummy.matrix);
            }
            scene.add(boxMesh);

            // --- 3. Candy Canes (Green & Gold) ---
            const caneGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.8, 8);
            
            // Green Cane Material (Glowing)
            const caneGreenMat = new THREE.MeshStandardMaterial({
                color: COLOR_GREEN_BRIGHT,
                emissive: COLOR_GREEN_BRIGHT,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            // Gold Cane Material (Glowing)
            const caneGoldMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD_METAL,
                emissive: COLOR_GOLD_METAL,
                emissiveIntensity: 0.3,
                metalness: 0.8,
                roughness: 0.2
            });

            // Split counts: 1/3 Green, 2/3 Gold
            const caneGreenCount = Math.floor(CANE_COUNT / 3);
            const caneGoldCount = CANE_COUNT - caneGreenCount;

            caneGreenMesh = new THREE.InstancedMesh(caneGeo, caneGreenMat, caneGreenCount);
            caneGoldMesh = new THREE.InstancedMesh(caneGeo, caneGoldMat, caneGoldCount);

            function fillCaneData(mesh, dataArray, count) {
                for(let i=0; i<count; i++) {
                    const t = Math.random();
                    const treePos = getTreePosition(t, 9, 24);
                    treePos.x *= 1.15; treePos.z *= 1.15; 
                    const scatteredPos = getScatteredPosition();
                    
                    dataArray.push({ treePos, scatteredPos, currentPos: treePos.clone() });
                    
                    dummy.position.copy(treePos);
                    dummy.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5); 
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                scene.add(mesh);
            }

            fillCaneData(caneGreenMesh, caneGreenData, caneGreenCount);
            fillCaneData(caneGoldMesh, caneGoldData, caneGoldCount);


            // --- 4. Glow Dust ---
            const glowGeo = new THREE.BufferGeometry();
            const glowPos = [];
            for(let i=0; i<GLOW_COUNT; i++) {
                const t = Math.random();
                const pos = getTreePosition(t, 12, 26); // Wider cloud
                glowPos.push(pos.x, pos.y, pos.z);
                glowData.push({
                    treePos: pos.clone(),
                    scatteredPos: getScatteredPosition(),
                    currentPos: pos.clone(),
                    speed: 0.02 + Math.random() * 0.05
                });
            }
            glowGeo.setAttribute('position', new THREE.Float32BufferAttribute(glowPos, 3));
            const glowMat = new THREE.PointsMaterial({
                color: 0xFFD700,
                size: 0.2,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            glowMesh = new THREE.Points(glowGeo, glowMat);
            scene.add(glowMesh);

            // --- 5. Top Star ---
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.8,
                metalness: 1.0,
                roughness: 0
            });
            starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.set(0, 26, 0);
            scene.add(starMesh);
        }

        // Handle Photo Upload
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Use callback to ensure image data (width/height) is ready
                    loader.load(e.target.result, (texture) => {
                        createPhotoMesh(texture);
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        function createPhotoMesh(texture) {
            // Correct color space
            texture.colorSpace = THREE.SRGBColorSpace;
            
            // Calculate Aspect Ratio (safe check)
            const img = texture.image;
            let aspect = 0.75; // Default 3:4
            if (img && img.width && img.height) {
                aspect = img.width / img.height;
            }
            
            const baseSize = 4; 
            let w, h;
            if (aspect > 1) {
                w = baseSize; 
                h = baseSize / aspect;
            } else {
                h = baseSize;
                w = baseSize * aspect;
            }

            const group = new THREE.Group();
            
            // Photo Plane 
            const geometry = new THREE.PlaneGeometry(w, h);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0,
                color: 0xffffff
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = 0.05; // Push OUTWARD (local Z)
            group.add(mesh);
            
            // Border Plane (Gold)
            const borderW = w + 0.2;
            const borderH = h + 0.2;
            const borderGeo = new THREE.PlaneGeometry(borderW, borderH);
            const borderMat = new THREE.MeshStandardMaterial({
                color: 0xD4AF37,
                metalness: 1.0,
                roughness: 0.2
            });
            const borderMesh = new THREE.Mesh(borderGeo, borderMat);
            borderMesh.position.z = 0;
            group.add(borderMesh);
            
            // Calculate Position
            const t = Math.random();
            const yPos = t * 24;
            const r = 13 * (1 - t * 0.95); // Slightly wider radius to float outside
            const theta = Math.random() * Math.PI * 2;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            const treePos = new THREE.Vector3(x, yPos + 2, z);
            
            const scatteredPos = getScatteredPosition();
            
            // Set Position
            group.position.copy(treePos);
            // Orient: Look AWAY from center. 
            // Current pos is (x,y,z). Center axis is (0,y,0).
            // Vector from center to pos is (x, 0, z).
            // We want group +Z to point along (x, 0, z).
            group.lookAt(x * 2, yPos + 2, z * 2); 
            
            photoData.push({
                mesh: group,
                treePos: treePos,
                scatteredPos: scatteredPos,
                treeRot: group.quaternion.clone(),
                scatteredRot: new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0))
            });
            
            scene.add(group);
            photos.push(group);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const lerpSpeed = 0.04;
            const dummy = new THREE.Object3D();
            
            if (currentState !== targetState) {
                currentState = targetState; 
            }
            
            // 1. Update Particles (Spheres)
            function updateSphereGroup(mesh, dataArray) {
                if (mesh) {
                    for (let i = 0; i < dataArray.length; i++) {
                        const data = dataArray[i];
                        let targetPos;
                        
                        if (targetState === STATE.CLOSED) {
                            targetPos = data.treePos;
                        } else {
                            targetPos = data.scatteredPos;
                        }
                        
                        // Lerp current position
                        data.currentPos.lerp(targetPos, lerpSpeed);
                        
                        dummy.position.copy(data.currentPos);
                        // In scattered state, add some floating motion
                        if (targetState !== STATE.CLOSED) {
                            dummy.position.y += Math.sin(Date.now() * 0.001 + i) * 0.02;
                        }
                        
                        dummy.scale.setScalar(targetState === STATE.CLOSED ? 0.7 : 1.0);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                    mesh.instanceMatrix.needsUpdate = true;
                }
            }

            updateSphereGroup(sphereGreenMesh, sphereGreenData);
            updateSphereGroup(sphereRedMesh, sphereRedData);
            updateSphereGroup(sphereGoldMesh, sphereGoldData);
            updateSphereGroup(sphereMatteMesh, sphereMatteData);
            
            // 2. Update Boxes
            if (boxMesh) {
                for (let i = 0; i < boxData.length; i++) {
                    const data = boxData[i];
                    let targetPos = (targetState === STATE.CLOSED) ? data.treePos : data.scatteredPos;
                    
                    data.currentPos.lerp(targetPos, lerpSpeed);
                    
                    dummy.position.copy(data.currentPos);
                    if (targetState !== STATE.CLOSED) {
                        dummy.rotation.x += 0.01;
                        dummy.rotation.y += 0.01;
                    }
                    dummy.updateMatrix();
                    boxMesh.setMatrixAt(i, dummy.matrix);
                }
                boxMesh.instanceMatrix.needsUpdate = true;
            }
            
            // 3. Canes
            function updateCaneGroup(mesh, dataArray) {
                if (mesh) {
                    for(let i = 0; i < dataArray.length; i++) {
                        const data = dataArray[i];
                        let targetPos = (targetState === STATE.CLOSED) ? data.treePos : data.scatteredPos;
                        data.currentPos.lerp(targetPos, lerpSpeed);
                        dummy.position.copy(data.currentPos);
                        dummy.rotation.z += 0.01; 
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                    mesh.instanceMatrix.needsUpdate = true;
                }
            }
            updateCaneGroup(caneGreenMesh, caneGreenData);
            updateCaneGroup(caneGoldMesh, caneGoldData);

            // 4. Glow Particles
            if (glowMesh) {
                const positions = glowMesh.geometry.attributes.position.array;
                for(let i=0; i<GLOW_COUNT; i++) {
                    const data = glowData[i];
                    let targetPos = (targetState === STATE.CLOSED) ? data.treePos : data.scatteredPos;
                    data.currentPos.lerp(targetPos, lerpSpeed);
                    
                    // Add drift
                    if (targetState !== STATE.CLOSED) {
                        data.currentPos.y += Math.sin(Date.now() * 0.001 + i) * 0.02;
                    }
                    
                    positions[i*3] = data.currentPos.x;
                    positions[i*3+1] = data.currentPos.y;
                    positions[i*3+2] = data.currentPos.z;
                }
                glowMesh.geometry.attributes.position.needsUpdate = true;
            }
            
            // 5. Star Rotation
            if (starMesh) {
                starMesh.rotation.y += 0.01;
                starMesh.position.y = THREE.MathUtils.lerp(starMesh.position.y, (targetState === STATE.CLOSED) ? 26 : 50, lerpSpeed);
                // Hide star in scattered mode? Or let it float high
                starMesh.scale.setScalar(THREE.MathUtils.lerp(starMesh.scale.x, (targetState === STATE.CLOSED) ? 1 : 0.1, lerpSpeed));
            }

            // 6. Photos
            photos.forEach((group, i) => {
                const data = photoData[i];
                let targetPos, targetRot;
                
                if (targetState === STATE.ZOOM && i === zoomedPhotoIndex) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    targetPos = camera.position.clone().add(camDir.multiplyScalar(6));
                    targetRot = camera.quaternion;
                    group.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
                } else {
                    targetPos = (targetState === STATE.CLOSED) ? data.treePos : data.scatteredPos;
                    targetRot = (targetState === STATE.CLOSED) ? data.treeRot : data.scatteredRot;
                    group.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }
                
                group.position.lerp(targetPos, lerpSpeed);
                group.quaternion.slerp(targetRot, lerpSpeed);
            });
            
            if (controls && controls.autoRotate) controls.update();
            if (composer) composer.render();
        }

        // --- MediaPipe Integration ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            camera.start();
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                detectGesture(results.multiHandLandmarks[0]);
            } else {
                 document.getElementById('gesture-state').innerText = "Á≠âÂæÖÊâãÂäø...";
            }
        }

        function detectGesture(landmarks) {
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            
            // 1. Pinch (Zoom)
            const pinchDist = dist(landmarks[4], landmarks[8]);
            // Needs to be VERY close to pinch
            if (pinchDist < 0.04) {
                if (currentState === STATE.SCATTERED && photos.length > 0) {
                    if (targetState !== STATE.ZOOM) {
                        targetState = STATE.ZOOM;
                        zoomedPhotoIndex = Math.floor(Math.random() * photos.length);
                        document.getElementById('gesture-state').innerText = "ü§å ÊäìÂèñÁÖßÁâá!";
                    }
                }
                return;
            }

            // 2. Open vs Closed
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let extendedCount = 0;
            
            // Thumb
            if (dist(landmarks[4], landmarks[17]) > 0.15) extendedCount++;
            // Fingers
            for (let i = 0; i < 4; i++) {
                if (dist(landmarks[tips[i]], landmarks[0]) > dist(landmarks[pips[i]], landmarks[0])) {
                    extendedCount++;
                }
            }

            if (extendedCount <= 1) { // Fist
                if (targetState !== STATE.CLOSED) {
                    targetState = STATE.CLOSED;
                    document.getElementById('gesture-state').innerText = "‚úä ËÅöÂêà (Âú£ËØûÊ†ë)";
                    controls.autoRotate = true; // Auto rotate in tree mode
                }
            } else if (extendedCount >= 4) { // Open
                if (targetState !== STATE.SCATTERED && targetState !== STATE.ZOOM) {
                    targetState = STATE.SCATTERED;
                    document.getElementById('gesture-state').innerText = "‚úã Êï£ÂºÄ (ÊòüÁ©∫)";
                } else if (targetState === STATE.ZOOM && extendedCount === 5) {
                     targetState = STATE.SCATTERED;
                     document.getElementById('gesture-state').innerText = "‚úã ÈáäÊîæÁÖßÁâá";
                }
            }

            // 3. Rotation (Hand Movement in Scattered Mode)
            if (currentState === STATE.SCATTERED && targetState === STATE.SCATTERED) {
                const handX = landmarks[9].x;
                // Center is 0.5. Left < 0.5, Right > 0.5
                // Rotate camera based on hand position relative to center
                const rotSpeed = (0.5 - handX) * 0.1; // Invert logic for natural feel
                if (Math.abs(rotSpeed) > 0.005) {
                    controls.autoRotate = false;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotSpeed);
                    camera.lookAt(0, 12, 0);
                    document.getElementById('gesture-state').innerText = "üëã ÊóãËΩ¨ËßÜËßí";
                }
            }
        }

        init();
    </script>
</body>
</html>
