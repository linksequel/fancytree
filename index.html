<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020818; color: white; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; border-radius: 8px; transform: scaleX(-1); opacity: 0.7; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none; }
        .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); pointer-events: auto; display: flex; gap: 10px; align-items: center; }
        button, input::file-selector-button, select {
            background: rgba(212, 175, 55, 0.8); border: 1px solid #D4AF37; color: #002200;
            padding: 8px 16px; border-radius: 20px; cursor: pointer; font-weight: bold;
            transition: all 0.3s;
            font-family: sans-serif;
            font-size: 14px;
        }
        button:hover, input::file-selector-button:hover, select:hover { background: #D4AF37; box-shadow: 0 0 10px #D4AF37; }
        select { outline: none; appearance: none; -webkit-appearance: none; padding-right: 30px; background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23002200%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E"); background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; }
        #status { position: absolute; top: 20px; right: 20px; text-align: right; text-shadow: 0 0 5px #D4AF37; }
        .instruction { font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; }
        h1 { margin: 0; font-size: 1.5em; color: #D4AF37; }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <video id="video-input" playsinline></video>
    <div id="ui-layer">
        <div id="status">
            <h1>Magic Christmas Tree</h1>
            <div class="instruction">‚úã Âº†ÂºÄÊâãÊéå: Êï£ÂºÄ | ‚úä Êè°Êã≥: ËÅöÂêà</div>
            <div class="instruction">üëÜ ÊçèÂêà: ÊäìÂèñÁÖßÁâá | üëã ÁßªÂä®: ÊóãËΩ¨ËßÜËßí</div>
            <div id="gesture-state" style="color: #ff3333; font-weight: bold; margin-top: 5px;">Á≠âÂæÖÊâãÂäø...</div>
        </div>
        <div class="controls">
            <select id="camera-select" title="ÈÄâÊã©ÊëÑÂÉèÂ§¥">
                <option value="" disabled selected>ÂØªÊâæÊëÑÂÉèÂ§¥...</option>
            </select>
            <input type="file" id="upload-photo" accept="image/*" multiple style="display:none">
            <button onclick="document.getElementById('upload-photo').click()">üì∏ ‰∏ä‰º†ÁÖßÁâá</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        // Particle Meshes
        let sphereMatteMesh, sphereGoldMesh, sphereRedMesh; // Foliage & Ornaments
        let boxGoldMesh, boxRedMesh; // Gifts/Decorations
        let caneRedMesh, caneGoldMesh; // Candy Canes
        let glowMesh; 
        let starMesh;
        let photoMeshes = [];
        
        // Spiral
        let spiralMesh;
        
        // Background Effects
        let auroraMesh;
        let shootingStars = [];

        // Data Arrays
        let sphereMatteData = [], sphereGoldData = [], sphereRedData = [];
        let boxGoldData = [], boxRedData = [];
        let caneRedData = [], caneGoldData = [];
        let glowData = [];
        let photoData = []; 
        let photos = [];
        
        // MediaPipe & Camera
        let hands;
        let videoStream;
        let animationFrameId;
        
        const PARTICLE_COUNT = 3500; // Increased count for denser foliage
        const BOX_COUNT = 400;
        const CANE_COUNT = 300;
        const GLOW_COUNT = 800;
        
        // State
        const STATE = {
            CLOSED: 0,
            SCATTERED: 1,
            ZOOM: 2
        };
        let currentState = STATE.CLOSED;
        let targetState = STATE.CLOSED;
        
        // Zoom State Variables
        let zoomedPhotoIndex = -1;
        let zoomCameraPos = new THREE.Vector3();
        let originalCameraPos = new THREE.Vector3();
        
        // Colors
        // Deep Pine Green, Metallic Gold, Christmas Red
        const COLOR_GREEN_MATTE = 0x1E792C; // Vibrant Pine Green
        const COLOR_GOLD_METAL = 0xFFD700;  // Bright Metallic Gold
        const COLOR_RED_CHRISTMAS = 0xC41E3A; // Cardinal/Christmas Red

        // --- Texture Generation Helpers ---
        function createStripedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = '#C41E3A'; // Red
            
            // Draw diagonal stripes
            for (let i = -64; i < 128; i += 16) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i + 16, 0);
                ctx.lineTo(i - 32 + 16, 64);
                ctx.lineTo(i - 32, 64);
                ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 4);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createNoiseTexture(colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorHex || '#FFFFFF';
            ctx.fillRect(0, 0, 64, 64);
            
            const imageData = ctx.getImageData(0, 0, 64, 64);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 20;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- Initialization ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020818, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 35);
            camera.lookAt(0, 12, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Ensure correct color space
            container.appendChild(renderer.domElement);

            // Post-processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.25; // Increase threshold to prevent non-emissive objects (like photos) from glowing too much
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Brighter ambient
            scene.add(ambientLight);

            // Main Gold Light - Warm and Bright
            const pointLight = new THREE.PointLight(0xFFD700, 3.0, 100);
            pointLight.position.set(5, 15, 20); 
            scene.add(pointLight);
            
            // Fill Light - Cooler to contrast
            const fillLight = new THREE.PointLight(0xccccff, 1, 80);
            fillLight.position.set(-10, 5, 20);
            scene.add(fillLight);
            
            // Internal Tree Lights (Warm Glow)
            const innerLight = new THREE.PointLight(0xffaa00, 3, 30);
            innerLight.position.set(0, 10, 0);
            scene.add(innerLight);
            
            // Add some random lights for sparkle
            for(let i=0; i<8; i++) {
                const color = Math.random() > 0.6 ? COLOR_GOLD_METAL : COLOR_RED_CHRISTMAS;
                const pl = new THREE.PointLight(color, 1.0, 30);
                pl.position.set((Math.random()-0.5)*20, Math.random()*25, (Math.random()-0.5)*20);
                scene.add(pl);
            }

            // Controls (Mouse fallback)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;
            controls.target.set(0, 10, 0);

            // Generate Particles
            generateParticles();
            
            // Create Background Effects (Aurora & Shooting Stars setup)
            createBackground();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('upload-photo').addEventListener('change', handlePhotoUpload);

            // Start Animation Loop
            animate();
            
            // Start MediaPipe
            initMediaPipe();
        }

        function getTreePosition(t, radiusBase, height) {
            // Volume filling cone
            const y = t * height; // 0 to H
            const maxR = radiusBase * (1 - t * 0.95); 
            // Random radius within maxR for volume
            const r = Math.sqrt(Math.random()) * maxR; 
            const theta = t * 40 + (Math.random() * Math.PI * 2); 
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            return new THREE.Vector3(x, y + 1, z); 
        }

        function getScatteredPosition() {
            const r = 12 + Math.random() * 15;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta) + 12; // Center around 12y
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        function generateParticles() {
            const dummy = new THREE.Object3D();

            // Helper to fill data
            function fillData(mesh, dataArray, count, scaleRange = [0.7, 1.5], rotation = false) {
                for (let i = 0; i < count; i++) {
                    const t = Math.pow(Math.random(), 0.8); // Bias towards bottom
                    const treePos = getTreePosition(t, 9, 24);
                    const scatteredPos = getScatteredPosition();
                    
                    // Add some noise to treePos for natural look
                    treePos.x += (Math.random() - 0.5) * 0.5;
                    treePos.z += (Math.random() - 0.5) * 0.5;

                    const s = scaleRange[0] + Math.random() * (scaleRange[1] - scaleRange[0]);
                    
                    // Random rotation
                    const rot = new THREE.Euler(
                        Math.random() * Math.PI, 
                        Math.random() * Math.PI, 
                        Math.random() * Math.PI
                    );

                    dataArray.push({ 
                        treePos, 
                        scatteredPos, 
                        currentPos: treePos.clone(),
                        scale: s,
                        rotation: rot, // Store initial rotation
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.02,
                            y: (Math.random() - 0.5) * 0.02,
                            z: (Math.random() - 0.5) * 0.02
                        }
                    });

                    dummy.position.copy(treePos);
                    if (rotation) {
                        dummy.rotation.copy(rot);
                    } else {
                        dummy.rotation.set(0,0,0);
                    }
                    dummy.scale.setScalar(s);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                scene.add(mesh);
            }

            // --- 1. Spheres (Foliage & Ornaments) ---
            
            // A. Foliage - Glowing Green (Brighter)
            // Brighter green particles instead of dark matte
            const sparkleGeo = new THREE.SphereGeometry(0.15, 8, 8); 
            const matSparkle = new THREE.MeshStandardMaterial({
                color: 0x44aa44, // Bright vivid green
                roughness: 0.4, 
                metalness: 0.3,
                emissive: 0x226622, // Green glow
                emissiveIntensity: 1.2, // Visible glow
                transparent: true,
                opacity: 0.9
            });
            // Keep the count high to define the tree shape with light
            const countMatte = Math.floor(PARTICLE_COUNT * 0.75); 
            sphereMatteMesh = new THREE.InstancedMesh(sparkleGeo, matSparkle, countMatte);
            fillData(sphereMatteMesh, sphereMatteData, countMatte, [0.6, 1.2]); 

            // B. Gold (Lights - Real Christmas Lights)
            // Smaller, glowing bulbs
            const lightGeo = new THREE.SphereGeometry(0.12, 16, 16); 
            const matLight = new THREE.MeshStandardMaterial({
                color: 0xffcc00, // Warm yellow light
                roughness: 0.4,
                metalness: 0.0,
                emissive: 0xffcc00,
                emissiveIntensity: 4.0, // Strong glow for bloom effect
                toneMapped: false // Keep colors bright
            });
            const countGold = Math.floor(PARTICLE_COUNT * 0.15);
            sphereGoldMesh = new THREE.InstancedMesh(lightGeo, matLight, countGold);
            fillData(sphereGoldMesh, sphereGoldData, countGold, [0.8, 1.2]); 

            // C. Red (Ornaments - Real Shiny Baubles)
            // Larger, reflective, glossy
            const ornamentGeo = new THREE.SphereGeometry(0.45, 32, 32);
            const matOrnament = new THREE.MeshPhysicalMaterial({
                color: 0xaa0000, // Deep Christmas Red
                roughness: 0.15,  // Smooth
                metalness: 0.5,   // Semi-metallic
                clearcoat: 1.0,   // Glossy polish
                clearcoatRoughness: 0.1,
                reflectivity: 1.0,
                specularIntensity: 1.0
            });
            const countRed = PARTICLE_COUNT - countMatte - countGold;
            sphereRedMesh = new THREE.InstancedMesh(ornamentGeo, matOrnament, countRed);
            fillData(sphereRedMesh, sphereRedData, countRed, [0.8, 1.5]); // Varied sizes for ornaments


            // --- 2. Boxes (Gifts - Gold & Red) ---
            const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            
            // Gold Boxes
            const boxGoldMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD_METAL,
                metalness: 1.0,
                roughness: 0.1,
                emissive: COLOR_GOLD_METAL,
                emissiveIntensity: 0.6
            });
            boxGoldMesh = new THREE.InstancedMesh(boxGeo, boxGoldMat, BOX_COUNT / 2);
            fillData(boxGoldMesh, boxGoldData, BOX_COUNT / 2, [0.8, 1.2], true);

            // Red Boxes
            const boxRedMat = new THREE.MeshStandardMaterial({
                color: COLOR_RED_CHRISTMAS,
                metalness: 0.5,
                roughness: 0.2,
                emissive: COLOR_RED_CHRISTMAS,
                emissiveIntensity: 0.6
            });
            boxRedMesh = new THREE.InstancedMesh(boxGeo, boxRedMat, BOX_COUNT / 2);
            fillData(boxRedMesh, boxRedData, BOX_COUNT / 2, [0.8, 1.2], true);


            // --- 3. Candy Canes (Red & Gold) ---
            const caneGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 12);
            const stripedTex = createStripedTexture();
            
            // Red Canes
            const caneRedMat = new THREE.MeshStandardMaterial({
                color: 0xffffff, // White base for texture
                map: stripedTex,
                metalness: 0.1,
                roughness: 0.3,
                emissive: 0x880000, // Red Glow
                emissiveIntensity: 0.5
            });
            caneRedMesh = new THREE.InstancedMesh(caneGeo, caneRedMat, CANE_COUNT / 2);
            fillData(caneRedMesh, caneRedData, CANE_COUNT / 2, [0.8, 1.2], true);

            // Gold Canes 
            const caneGoldMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD_METAL,
                metalness: 0.9,
                roughness: 0.2,
                emissive: COLOR_GOLD_METAL,
                emissiveIntensity: 0.6
            });
            caneGoldMesh = new THREE.InstancedMesh(caneGeo, caneGoldMat, CANE_COUNT / 2);
            fillData(caneGoldMesh, caneGoldData, CANE_COUNT / 2, [0.8, 1.2], true);


            // --- 4. Glow Dust ---
            const glowGeo = new THREE.BufferGeometry();
            const glowPos = [];
            for(let i=0; i<GLOW_COUNT; i++) {
                const t = Math.random();
                const pos = getTreePosition(t, 12, 26); // Wider cloud
                glowPos.push(pos.x, pos.y, pos.z);
                glowData.push({
                    treePos: pos.clone(),
                    scatteredPos: getScatteredPosition(),
                    currentPos: pos.clone(),
                    speed: 0.02 + Math.random() * 0.05
                });
            }
            glowGeo.setAttribute('position', new THREE.Float32BufferAttribute(glowPos, 3));
            const glowMat = new THREE.PointsMaterial({
                color: COLOR_GOLD_METAL,
                size: 0.25,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            glowMesh = new THREE.Points(glowGeo, glowMat);
            scene.add(glowMesh);

            // --- 5. Top Star ---
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD_METAL,
                emissive: COLOR_GOLD_METAL,
                emissiveIntensity: 2.0, // Super bright
                metalness: 1.0,
                roughness: 0
            });
            starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.set(0, 26, 0);
            scene.add(starMesh);

            // --- 6. Spiral Runner (Golden Marquee) ---
            const spiralPoints = [];
            const spiralHeight = 25;
            const turns = 6;
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const angle = t * Math.PI * 2 * turns;
                const radius = 10 * (1 - t * 0.9) + 1; // Tapering radius
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = t * spiralHeight + 1;
                spiralPoints.push(new THREE.Vector3(x, y, z));
            }
            const spiralCurve = new THREE.CatmullRomCurve3(spiralPoints);
            const tubeGeo = new THREE.TubeGeometry(spiralCurve, 100, 0.3, 8, false);
            
            // Texture for flow effect
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            // Gradient stripes
            const gradient = ctx.createLinearGradient(0, 0, 128, 0);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0)');
            gradient.addColorStop(0.5, 'rgba(255, 215, 0, 1)'); // Gold center
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 32);
            
            const spiralTex = new THREE.CanvasTexture(canvas);
            spiralTex.wrapS = THREE.RepeatWrapping;
            spiralTex.wrapT = THREE.RepeatWrapping;
            spiralTex.repeat.set(5, 1); // 5 repeating segments
            
            const spiralMat = new THREE.MeshBasicMaterial({
                map: spiralTex,
                transparent: true,
                opacity: 0.25, // Lower opacity for subtle effect
                color: 0xFFD700,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            spiralMesh = new THREE.Mesh(tubeGeo, spiralMat);
            scene.add(spiralMesh);
        }

        function createBackground() {
            // 1. Aurora Borealis (Shader)
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                uniform float time;
                varying vec2 vUv;
                
                // Simplex Noise (Simplified)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                    vec2 i  = floor(v + dot(v, C.yy) );
                    vec2 x0 = v - i + dot(i, C.xx);
                    vec2 i1;
                    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i);
                    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                    m = m*m ;
                    m = m*m ;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                    vec3 g;
                    g.x  = a0.x  * x0.x  + h.x  * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                void main() {
                    vec2 uv = vUv;
                    // Add wave movement
                    float noise1 = snoise(vec2(uv.x * 2.0 + time * 0.1, uv.y * 3.0 - time * 0.2));
                    float noise2 = snoise(vec2(uv.x * 4.0 - time * 0.15, uv.y * 1.5 + time * 0.05));
                    
                    float intensity = (noise1 + noise2) * 0.5 + 0.5;
                    // Fade edges
                    intensity *= smoothstep(0.0, 0.2, uv.y) * smoothstep(1.0, 0.5, uv.y);
                    
                    // Colors: Green/Teal to Purple - BOOSTED INTENSITY
                    vec3 color1 = vec3(0.1, 1.0, 0.6); // Neon Green
                    vec3 color2 = vec3(0.6, 0.0, 1.0); // Bright Purple
                    
                    vec3 finalColor = mix(color1, color2, uv.y + noise1 * 0.3);
                    
                    // Boost opacity and ensure visible
                    float alpha = intensity * 0.8; // Higher base opacity
                    // Make sure it doesn't fade too much at top, only bottom
                    alpha *= smoothstep(0.0, 0.3, uv.y);
                    
                    gl_FragColor = vec4(finalColor, alpha); 
                }
            `;
            
            // Create a large cylinder or curved plane in the background
            const geo = new THREE.CylinderGeometry(80, 80, 60, 64, 8, true); // Larger cylinder
            // Invert normals to see from inside
            geo.scale(-1, 1, 1); 
            
            const mat = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    time: { value: 0 }
                },
                transparent: true,
                side: THREE.BackSide, 
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            auroraMesh = new THREE.Mesh(geo, mat);
            auroraMesh.position.y = 20; // Lifted up slightly
            scene.add(auroraMesh);
        }

        // Handle Photo Upload
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Use callback to ensure image data (width/height) is ready
                    loader.load(e.target.result, (texture) => {
                        createPhotoMesh(texture);
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        function createPhotoMesh(texture) {
            // Correct color space
            texture.colorSpace = THREE.SRGBColorSpace;
            
            // Calculate Aspect Ratio (safe check)
            const img = texture.image;
            let aspect = 0.75; // Default 3:4
            if (img && img.width && img.height) {
                aspect = img.width / img.height;
            }
            
            const baseSize = 4; 
            let w, h;
            if (aspect > 1) {
                w = baseSize; 
                h = baseSize / aspect;
            } else {
                h = baseSize;
                w = baseSize * aspect;
            }

            const group = new THREE.Group();
            
            // Photo Plane 
            const geometry = new THREE.PlaneGeometry(w, h);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0,
                color: 0xffffff, // ÊÅ¢Â§çÁôΩËâ≤‰ª•ÊòæÁ§∫ÁÖßÁâáÂéüËâ≤ (Restore white to show original photo colors)
                roughness: 0.5,  // ÂçäÂìëÂÖâË¥®ÊÑüÔºåÊ®°ÊãüÁÖßÁâáÁ∫∏ (Semi-matte finish)
                metalness: 0.0
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = 0.05; // Push OUTWARD (local Z)
            group.add(mesh);
            
            // Border Plane (Gold)
            const borderW = w + 0.2;
            const borderH = h + 0.2;
            const borderGeo = new THREE.PlaneGeometry(borderW, borderH);
            const borderMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD_METAL,
                metalness: 1.0,
                roughness: 0.2
            });
            const borderMesh = new THREE.Mesh(borderGeo, borderMat);
            borderMesh.position.z = 0;
            group.add(borderMesh);
            
            // Calculate Position
            const t = Math.random();
            const yPos = t * 24;
            const r = 13 * (1 - t * 0.95); // Slightly wider radius to float outside
            const theta = Math.random() * Math.PI * 2;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            const treePos = new THREE.Vector3(x, yPos + 2, z);
            
            const scatteredPos = getScatteredPosition();
            
            // Set Position
            group.position.copy(treePos);
            // Orient: Look AWAY from center. 
            // Current pos is (x,y,z). Center axis is (0,y,0).
            // Vector from center to pos is (x, 0, z).
            // We want group +Z to point along (x, 0, z).
            group.lookAt(x * 2, yPos + 2, z * 2); 
            
            photoData.push({
                mesh: group,
                treePos: treePos,
                scatteredPos: scatteredPos,
                treeRot: group.quaternion.clone(),
                scatteredRot: new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0))
            });
            
            scene.add(group);
            photos.push(group);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const lerpSpeed = 0.04;
            const dummy = new THREE.Object3D();
            
            if (currentState !== targetState) {
                currentState = targetState; 
            }
            
            // Generic update function for instanced meshes
            function updateGroup(mesh, dataArray) {
                if (!mesh) return;
                for (let i = 0; i < dataArray.length; i++) {
                    const data = dataArray[i];
                    let targetPos;
                    
                    if (targetState === STATE.CLOSED) {
                        targetPos = data.treePos;
                    } else {
                        targetPos = data.scatteredPos;
                    }
                    
                    // Lerp Position
                    data.currentPos.lerp(targetPos, lerpSpeed);
                    dummy.position.copy(data.currentPos);

                    // Add floating motion in scattered state
                    if (targetState !== STATE.CLOSED) {
                        dummy.position.y += Math.sin(Date.now() * 0.001 + i) * 0.02;
                    }
                    
                    // Rotation
                    // Use stored rotation as base
                    if (data.rotation) {
                        // If scattered, rotate continuously
                        if (targetState !== STATE.CLOSED && data.rotationSpeed) {
                            data.rotation.x += data.rotationSpeed.x;
                            data.rotation.y += data.rotationSpeed.y;
                            data.rotation.z += data.rotationSpeed.z;
                        }
                        dummy.rotation.copy(data.rotation);
                    } else {
                        dummy.rotation.set(0,0,0);
                    }

                    // Scale
                    let s = data.scale || 1.0;
                    if (targetState === STATE.CLOSED) {
                        s *= 0.8; // Slightly smaller when packed in tree
                    }
                    dummy.scale.setScalar(s);

                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
            }

            // Update all groups
            updateGroup(sphereMatteMesh, sphereMatteData);
            updateGroup(sphereGoldMesh, sphereGoldData);
            
            // Twinkle Lights Animation
            if (sphereGoldMesh && sphereGoldMesh.material) {
                // Breathing glow effect
                const time = Date.now() * 0.003;
                sphereGoldMesh.material.emissiveIntensity = 3.0 + Math.sin(time) * 1.5;
            }

            updateGroup(sphereRedMesh, sphereRedData);
            
            updateGroup(boxGoldMesh, boxGoldData);
            updateGroup(boxRedMesh, boxRedData);
            
            updateGroup(caneRedMesh, caneRedData);
            updateGroup(caneGoldMesh, caneGoldData);

            // 4. Glow Particles
            if (glowMesh) {
                const positions = glowMesh.geometry.attributes.position.array;
                for(let i=0; i<GLOW_COUNT; i++) {
                    const data = glowData[i];
                    let targetPos = (targetState === STATE.CLOSED) ? data.treePos : data.scatteredPos;
                    data.currentPos.lerp(targetPos, lerpSpeed);
                    
                    // Add drift
                    if (targetState !== STATE.CLOSED) {
                        data.currentPos.y += Math.sin(Date.now() * 0.001 + i) * 0.02;
                    }
                    
                    positions[i*3] = data.currentPos.x;
                    positions[i*3+1] = data.currentPos.y;
                    positions[i*3+2] = data.currentPos.z;
                }
                glowMesh.geometry.attributes.position.needsUpdate = true;
            }
            
            // 5. Star Rotation
            if (starMesh) {
                starMesh.rotation.y += 0.01;
                starMesh.position.y = THREE.MathUtils.lerp(starMesh.position.y, (targetState === STATE.CLOSED) ? 26 : 50, lerpSpeed);
                starMesh.scale.setScalar(THREE.MathUtils.lerp(starMesh.scale.x, (targetState === STATE.CLOSED) ? 1 : 0.1, lerpSpeed));
            }

            // 6. Spiral Animation
            if (spiralMesh) {
                spiralMesh.material.map.offset.x -= 0.01; // Move texture
                
                // Show only in Tree Mode
                const targetScale = (targetState === STATE.CLOSED) ? 1 : 0;
                spiralMesh.visible = spiralMesh.scale.x > 0.01;
                spiralMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpSpeed);
            }
            
            // 7. Background Effects Update
            if (auroraMesh) {
                auroraMesh.material.uniforms.time.value = Date.now() * 0.001;
            }
            
            // Shooting Stars Logic
            // Spawn probability - METEOR SHOWER (Extreme Density)
            const spawnLoop = (Math.random() < 0.3) ? 2 : 1; 
            
            for(let s=0; s<spawnLoop; s++) {
                if (Math.random() < 0.7) { 
                    // Use a Group to hold head and trail
                    const starGroup = new THREE.Group();
                    
                    // 1. Star Head (Glowing Sphere)
                    const headGeo = new THREE.SphereGeometry(0.4, 8, 8); // Thicker head
                    const headMat = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 1.0
                    });
                    const head = new THREE.Mesh(headGeo, headMat);
                    starGroup.add(head);
                    
                    // 2. Trail (Cone for volume)
                    // Pointing backwards along Z
                    const trailLen = 6 + Math.random() * 6;
                    const trailGeo = new THREE.ConeGeometry(0.3, trailLen, 8, 1, true); // Open ended cone
                    // Rotate cone to align with Z axis (default is Y)
                    trailGeo.rotateX(Math.PI / 2); 
                    trailGeo.translate(0, 0, trailLen / 2); // Shift so tip is at origin
                    
                    const trailMat = new THREE.MeshBasicMaterial({
                        color: 0xaaddff, // Light Blue trail
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    starGroup.add(trail);
                    
                    // Random start position 
                    const startX = (Math.random() - 0.5) * 120; 
                    const startY = 50 + Math.random() * 40;     
                    const startZ = -60 + (Math.random() - 0.5) * 80; 
                    
                    starGroup.position.set(startX, startY, startZ);
                    
                    // Random direction 
                    starGroup.lookAt(startX + (Math.random()-0.5)*20, startY - 40, startZ + (Math.random()-0.5)*20);
                    
                    scene.add(starGroup);
                    shootingStars.push({ mesh: starGroup, speed: 2.5 + Math.random() * 2.5 }); 
                }
            }
            
            // Update & Cleanup Shooting Stars
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const s = shootingStars[i];
                s.mesh.translateZ(s.speed); // Move forward along local Z
                
                // Fade out both children
                s.mesh.children.forEach(c => {
                    if(c.material) c.material.opacity -= 0.015;
                });
                
                // Check opacity of head
                if (s.mesh.children[0].material.opacity <= 0) {
                    scene.remove(s.mesh);
                    // Dispose
                    s.mesh.traverse((object) => {
                        if (object.isMesh) {
                            object.geometry.dispose();
                            object.material.dispose();
                        }
                    });
                    shootingStars.splice(i, 1);
                }
            }
            
            // 8. Photos
            photos.forEach((group, i) => {
                const data = photoData[i];
                let targetPos, targetRot;
                
                if (targetState === STATE.ZOOM && i === zoomedPhotoIndex) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    targetPos = camera.position.clone().add(camDir.multiplyScalar(6));
                    targetRot = camera.quaternion;
                    group.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
                } else {
                    targetPos = (targetState === STATE.CLOSED) ? data.treePos : data.scatteredPos;
                    targetRot = (targetState === STATE.CLOSED) ? data.treeRot : data.scatteredRot;
                    group.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }
                
                group.position.lerp(targetPos, lerpSpeed);
                group.quaternion.slerp(targetRot, lerpSpeed);
            });
            
            if (controls && controls.autoRotate) controls.update();
            if (composer) composer.render();
        }

        // --- MediaPipe Integration & Camera Handling ---
        async function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            
            // Initialize Hands
            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            // Initialize Camera List
            await getCameras();
        }

        async function getCameras() {
            try {
                // Request permission first to get labels
                const initialStream = await navigator.mediaDevices.getUserMedia({ video: true });
                // Stop the initial stream immediately, we just needed permission/labels
                initialStream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const cameraSelect = document.getElementById('camera-select');
                
                cameraSelect.innerHTML = '';
                
                if (videoDevices.length === 0) {
                    const option = document.createElement('option');
                    option.text = "Êú™ÊâæÂà∞ÊëÑÂÉèÂ§¥";
                    cameraSelect.add(option);
                    return;
                }

                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `ÊëÑÂÉèÂ§¥ ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                cameraSelect.onchange = () => {
                    startCamera(cameraSelect.value);
                };

                // Select the last used camera or the first available one
                // On desktop with external cam, it might be the second one, so listing them is key.
                if (videoDevices.length > 0) {
                    // Default to the first one
                    startCamera(videoDevices[0].deviceId);
                }

            } catch (err) {
                console.error("Error enumerating devices:", err);
                const cameraSelect = document.getElementById('camera-select');
                cameraSelect.innerHTML = '<option>ÊëÑÂÉèÂ§¥ËÆøÈóÆÂèóÈôê</option>';
            }
        }

        async function startCamera(deviceId) {
            const videoElement = document.getElementById('video-input');
            
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            const constraints = {
                video: {
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };
            
            try {
                videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = videoStream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    processVideo();
                };
            } catch (err) {
                console.error("Error starting camera:", err);
                alert("Êó†Ê≥ïÂêØÂä®ÊëÑÂÉèÂ§¥ÔºåËØ∑ÈáçËØïÊàñÈÄâÊã©ÂÖ∂‰ªñËÆæÂ§á");
            }
        }

        async function processVideo() {
            const videoElement = document.getElementById('video-input');
            
            if (hands && videoElement.readyState >= 2) {
                await hands.send({image: videoElement});
            }
            
            if (!videoElement.paused && !videoElement.ended) {
                animationFrameId = requestAnimationFrame(processVideo);
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                detectGesture(results.multiHandLandmarks[0]);
            } else {
                 document.getElementById('gesture-state').innerText = "Á≠âÂæÖÊâãÂäø...";
            }
        }

        function detectGesture(landmarks) {
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            
            // 1. Pinch (Zoom)
            const pinchDist = dist(landmarks[4], landmarks[8]);
            // Needs to be VERY close to pinch
            if (pinchDist < 0.04) {
                if (currentState === STATE.SCATTERED && photos.length > 0) {
                    if (targetState !== STATE.ZOOM) {
                        targetState = STATE.ZOOM;
                        zoomedPhotoIndex = Math.floor(Math.random() * photos.length);
                        document.getElementById('gesture-state').innerText = "ü§å ÊäìÂèñÁÖßÁâá!";
                    }
                }
                return;
            }

            // 2. Open vs Closed
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let extendedCount = 0;
            
            // Thumb
            if (dist(landmarks[4], landmarks[17]) > 0.15) extendedCount++;
            // Fingers
            for (let i = 0; i < 4; i++) {
                if (dist(landmarks[tips[i]], landmarks[0]) > dist(landmarks[pips[i]], landmarks[0])) {
                    extendedCount++;
                }
            }

            if (extendedCount <= 1) { // Fist
                if (targetState !== STATE.CLOSED) {
                    targetState = STATE.CLOSED;
                    document.getElementById('gesture-state').innerText = "‚úä ËÅöÂêà (Âú£ËØûÊ†ë)";
                    controls.autoRotate = true; // Auto rotate in tree mode
                }
            } else if (extendedCount >= 4) { // Open
                if (targetState !== STATE.SCATTERED && targetState !== STATE.ZOOM) {
                    targetState = STATE.SCATTERED;
                    document.getElementById('gesture-state').innerText = "‚úã Êï£ÂºÄ (ÊòüÁ©∫)";
                } else if (targetState === STATE.ZOOM && extendedCount === 5) {
                     targetState = STATE.SCATTERED;
                     document.getElementById('gesture-state').innerText = "‚úã ÈáäÊîæÁÖßÁâá";
                }
            }

            // 3. Rotation (Hand Movement in Scattered Mode)
            if (currentState === STATE.SCATTERED && targetState === STATE.SCATTERED) {
                const handX = landmarks[9].x;
                // Center is 0.5. Left < 0.5, Right > 0.5
                // Rotate camera based on hand position relative to center
                const rotSpeed = (0.5 - handX) * 0.1; // Invert logic for natural feel
                if (Math.abs(rotSpeed) > 0.005) {
                    controls.autoRotate = false;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotSpeed);
                    camera.lookAt(0, 12, 0);
                    document.getElementById('gesture-state').innerText = "üëã ÊóãËΩ¨ËßÜËßí";
                }
            }
        }

        init();
    </script>
</body>
</html>
